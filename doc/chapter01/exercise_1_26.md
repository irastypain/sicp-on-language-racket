# [Глава 1. Построение абстракций с помощью процедур](index.md#Глава-1-Построение-абстракций-с-помощью-процедур)
## [1.2. Процедуры и порождаемые ими процессы](index.md#12-Процедуры-и-порождаемые-ими-процессы)

### Упражнение 1.26
У Хьюго Дума большие трудности в упражнении 1.24. Процедура `fast-prime?` у него
работает медленнее, чем `prime?`. Хьюго просит помощи у своей знакомой Евы Лу
Атор. Вместе изучая код Хьюго, они обнаруживают, что тот переписал процедуру
`expmod` с явным использованием умножения вместо того, чтобы вызывать `square`:

```racket
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (* (expmod base (/ exp 2) m)
                       (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))
```

Хьюго говорит: «Я не вижу здесь никакой разницы». «Зато я вижу, — отвечает Ева.
— Переписав процедуру таким образом, ты превратил процесс порядка _Θ(log n)_ в
процесс порядка _Θ(n)_». Объясните.

#### Решение
Так как в решении Хьюго процедура `expmod` вызывает саму себя внутри себя дважды,
то можно говорить о том, что потребуется не просто в _2_ раза больше операций, а
в _2ˡᵒᵍⁿ_, что даёт нам в итоге _n_. Остюда и получаем, что процесс становится
линейным в росте числа шагов. Таким образом, порядок будет _Θ(n)_.
