# [Глава 1. Построение абстракций с помощью процедур](index.md#Глава-1-Построение-абстракций-с-помощью-процедур)
## [1.2. Процедуры и порождаемые ими процессы](index.md#12-Процедуры-и-порождаемые-ими-процессы)

### Упражнение 1.17
Алгоритмы возведения в степень из этого раздела основаны на повторяющемся
умножении. Подобным же образом можно производить умножение с помощью
повторяющегося сложения. Следующая процедура умножения (в которой предполагается,
что наш язык способен только складывать, но не умножать) аналогична процедуре
`expt`:

```racket
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
```

Этот алгоритм затрачивает количество шагов, линейно пропорциональное _b_.
Предположим теперь, что, наряду со сложением, у нас есть операции `double`,
которая удваивает целое число, и `halve`, которая делит (четное) число на 2.
Используя их, напишите процедуру, аналогичную `fast-expt`, которая затрачивает
логарифмическое число шагов.

#### Решение

[Код](../../src/chapter01/exercise_1_17.rkt) | [Тест](../../test/chapter01/exercise_1_17-test.rkt)
--- | ---
