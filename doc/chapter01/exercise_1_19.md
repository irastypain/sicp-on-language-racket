# [Глава 1. Построение абстракций с помощью процедур](index.md#Глава-1-Построение-абстракций-с-помощью-процедур)
## [1.2. Процедуры и порождаемые ими процессы](index.md#12-Процедуры-и-порождаемые-ими-процессы)

### Упражнение 1.19
Существует хитрый алгоритм получения чисел Фибоначчи за логарифмическое число
шагов. Вспомните трансформацию переменных состояния _`a`_ и _`b`_ процесса
`fib-iter` из раздела 1.2.2: _`a ← a + b`_ и _`b ← a`_. Назовем эту
трансформацию _`T`_ и заметим, что _n_-кратное применение _`T`_, начиная с 1 и
0, дает нам пару _`Fib(n + 1)`_ и _`Fib(n)`_. Другими словами, числа Фибоначчи
получаются путем применения _`Tn`_, _`n`_-ой степени трансформации _`T`_, к паре
_`(1,0)`_. Теперь рассмотрим _`T`_ как частный случай _`p`_ = 0, _`q`_ = 1 в
семействе трансформаций _`T pq`_, где _`Tpq`_ преобразует пару _`(a, b)`_ по
правилу _`a ← bq + aq + ap`_, _`b ← bp + aq`_. Покажите, что двукратное
применение трансформации _`Tpq`_ равносильно однократному применению
трансформации _`Tp′q′`_ того же типа, и вычислите _`p′`_ и _`q′`_ через _`p`_ и
_`q`_. Это даёт нам прямой способ возводить такие трансформации в квадрат, и
таким образом, мы можем вычислить _`Tn`_ с помощью последовательного возведения
в квадрат, как в процедуре `fast-expt`. Используя все эти идеи, завершите
следующую процедуру, которая даёт результат за логарифмическое число шагов:

```racket
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   〈??〉 ; вычислить p'
                   〈??〉 ; вычислить q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
```

#### Решение
Трансформация _`Tpq`_ преобразует пару _`(a, b)`_ в пару _`(bq + aq + ap, bp + aq)`_.
Записать это можно так: _`Tpq(a, b)`_ = _`(bq + aq + ap, bp + aq)`_.

Теперь покажем, что двукратное применение трансформации _`Tpq`_ равносильно
однократному применению трансформации _`Tp′q′`_ того же типа.

_`Tpq²(a, b)`_ = _`Tpq(Tpq(a, b))`_ = _`Tpq(bq + aq + ap, bp + aq)`_ =
_`([bp + aq]q + [bq + aq + ap]q + [bq + aq + ap]p, [bp + aq]p + [bq + aq + ap]q)`_ =
_`(bpq + aq² + bq² + aq² + apq + bpq + apq + ap², bp² + apq + bq² + aq² + apq)`_ =
_`(2bpq + bq² + 2apq + aq² + ap² + aq², bp² + bq² + 2apq + aq²)`_ =
_`(b[2pq + q²] + a[2pq + q²] + a[p² + q²], b[p² + q²] + a[2pq + q²])`_ =
_`(bq' + aq' + ap', bp' + aq')`_ = _`Tp'q'(a, b)`_,

где _`p'`_ = _`p² + q²`_, _`q'`_ = _`2pq + q²`_.

Соответственно, в терминах процедуры, вычислимые _`p'`_ и _`q'`_ имеют вид:

```racket
(+ (square p) (square q)) ; p'
(+ (* 2 p q) (square q))  ; q'
```

[Код](../../src/chapter01/exercise_1_19.rkt) | [Тест](../../test/chapter01/test_exercise_1_19.rkt)
--- | ---
