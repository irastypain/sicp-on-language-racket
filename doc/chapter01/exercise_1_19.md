# [Глава 1. Построение абстракций с помощью процедур](index.md#Глава-1-Построение-абстракций-с-помощью-процедур)
## [1.2. Процедуры и порождаемые ими процессы](index.md#12-Процедуры-и-порождаемые-ими-процессы)

### Упражнение 1.19
Существует хитрый алгоритм получения чисел Фибоначчи за логарифмическое число
шагов. Вспомните трансформацию переменных состояния _a_ и _b_ процесса `fib-iter`
из раздела 1.2.2: _a ← a + b_ и _b ← a_. Назовем эту трансформацию _T_ и заметим,
что _n_-кратное применение _T_, начиная с 1 и 0, дает нам пару _Fib(n + 1)_ и
_Fib(n)_. Другими словами, числа Фибоначчи получаются путем применения _Tn_,
_n_-ой степени трансформации _T_, к паре _(1,0)_. Теперь рассмотрим _T_ как
частный случай _p_ = 0, _q_ = 1 в семействе трансформаций _T pq_, где _Tpq_
преобразует пару _(a, b)_ по правилу _a ← bq + aq + ap_, _b ← bp + aq_. Покажите,
что двукратное применение трансформации _Tpq_ равносильно однократному применению
трансформации _Tp′q′_ того же типа, и вычислите _p′_ и _q′_ через _p_ и _q_. Это
даёт нам прямой способ возводить такие трансформации в квадрат, и таким образом,
мы можем вычислить _Tn_ с помощью последовательного возведения в квадрат, как в
процедуре `fast-expt`. Используя все эти идеи, завершите следующую процедуру,
которая даёт результат за логарифмическое число шагов:

```racket
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   〈??〉 ; вычислить p'
                   〈??〉 ; вычислить q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
```

#### Решение
Трансформация _Tpq_ преобразует пару _(a, b)_ в пару _(bq + aq + ap, bp + aq)_.
Записать это можно так: _Tpq(a, b) = _(bq + aq + ap, bp + aq)_.

Теперь покажем, что двукратное применение трансформации _Tpq_ равносильно
однократному применению трансформации _Tp′q′_ того же типа.

_Tpq²(a, b)_ = _Tpq(Tpq(a, b))_ = _Tpq(bq + aq + ap, bp + aq)_ =
_([bp + aq]q + [bq + aq + ap]q + [bq + aq + ap]p, [bp + aq]p + [bq + aq + ap]q)_ =
_(bpq + aq² + bq² + aq² + apq + bpq + apq + ap², bp² + apq + bq² + aq² + apq)_ =
_(2bpq + bq² + 2apq + aq² + ap² + aq², bp² + bq² + 2apq + aq²)_ =
_(b[2pq + q²] + a[2pq + q²] + a[p² + q²], b[p² + q²] + a[2pq + q²])_ =
_(bq' + aq' + ap', bp' + aq')_ = _Tp'q'(a, b)_,

где _p'_ = _p² + q²_, _q'_ = _2pq + q²_.

Соответственно, в терминах процедуры, вычислимые _p'_ и _q'_ имеют вид:

```racket
(+ (square p) (square q)) ; p'
(+ (* 2 p q) (square q))  ; q'
```

[Код](../../src/chapter01/exercise_1_19.rkt) | [Тест](../../test/chapter01/test_exercise_1_19.rkt)
--- | ---
