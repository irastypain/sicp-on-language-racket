# [Глава 1. Построение абстракций с помощью процедур](index.md#Глава-1-Построение-абстракций-с-помощью-процедур)
## [1.1 Элементы программирования](index.md#11-Элементы-программирования)

### Упражнение 1.5
Бен Битобор придумал тест для проверки интерпретатора на то, с каким порядком
вычислений он работает, аппликативным или нормальным. Бен определяет такие две
процедуры:

```racket
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
```

Затем он вычисляет выражение

```racket
(test 0 (p))
```

Какое поведение увидит Бен, если интерпретатор использует аппликативный порядок
вычислений? Какое поведение он увидит, если интерпретатор использует нормальный
порядок? Объясните Ваш ответ. (Предполагается, что правило вычисления особой
формы `if` одинаково независимо от того, какой порядок вычислений используется.
Сначала вычисляется выражение-предикат, и результат определяет, нужно ли
вычислять выражение-следствие или альтернативу.)

#### Решение
Если интерпретатор использует _аппликативный_ порядок вычислений, то при выполнении
процедуры `test` интерпретатор сначала вычислит значения аргументов, а после
выполнит саму процедуру с вычисленными аргументами. Но так как второй вычисляемый
аргумент является рекурсивной процедурой, то интерпретатор будет "бесконечно"
выполнять процедуру `p`. Что в конечном итоге приведёт к исчерпанию памяти, и
интерпретатор завершит свою работу с ошибкой вычислений.

Если интерпретатор использует _нормальный_ порядок вычислений, то при выполнении
процедуры `test` интерпретатор передаст аргументы внутрь процедуры до того момента,
когда не потребуются их значения. В этом случае процедура завершится корректно,
так как до вычисления процедуры `p` дело не дойдёт.
