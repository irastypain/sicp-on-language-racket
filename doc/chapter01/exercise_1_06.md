# [Глава 1. Построение абстракций с помощью процедур](index.md)

## Упражнение 1.6
Лиза П. Хакер не понимает, почему `if` должна быть особой формой. "Почему нельзя
просто определить ее как обычную процедуру с помощью `cond`?" — спрашивает она.
Лизина подруга Ева Лу Атор утверждает, что, разумеется, можно, и определяет новую
версию `if`:

```racket
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
```

Ева показывает Лизе новую программу:

```racket
(new-if (= 2 3) 0 5)
; => 5

(new-if (= 1 1) 0 5)
; => 0
```

Обрадованная Лиза переписывает через `new-if` программу вычисления квадратного
корня:

```racket
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))
```

Что получится, когда Лиза попытается использовать эту процедуру для вычисления
квадратных корней? Объясните.

### Решение
`new-if` в данном случае является процедурой. А поскольку у нашего интерпретатора
аппликативный порядок вычислений, порядок вычисления процедуры будет такой:

  1. Вычисление `(good-enough? guess x)`
  2. Вычисление `(improve guess x)`
  3. Вычисление `(sqrt-iter (improve guess x))`
  
На третьем этапе вычислений аргументов процедуры `new-if` интерпретатор начнёт
вычислять аргументы процедуры `sqrt-iter`, которая определена рекурсивно. Что
приведёт к зацикливанию и исчепанию памяти. Процедура завершится с ошибкой.
Чтобы такого не происходило, и были введены _особые_ формы, такие как `if`,
`cond` и другие.
