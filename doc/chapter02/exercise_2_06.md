# [Глава 2. Построение абстракций с помощью данных](index.md#Глава-2-Построение-абстракций-с-помощью-данных)
## [2.1 Введение в абстракцию данных](index.md#21-Введение-в-абстракцию-данных)

### Упражнение 2.6
Если представление пар как процедур было для Вас еще недостаточно сумасшедшим,
то заметьте, что в языке, который способен манипулировать процедурами, мы можем
обойтись и без чисел (по крайней мере, пока речь идет о неотрицательных числах),
определив 0 и операцию прибавления 1 так:

```racket
(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
```

Такое представление известно как _числа Чёрча_ (Church numerals), по имени его
изобретателя, Алонсо Чёрча, того самого логика, который придумал _λ_-исчисление.
Определите `one` (единицу) и `two` (двойку) напрямую (не через `zero` и `add-1`).
(Подсказка: вычислите `(add-1 zero)` с помощью подстановки.) Дайте прямое
определение процедуры сложения `+` (не в терминах повторяющегося применения
`add-1`).

#### Решение
Определим `one` (единицу) как применение процедуры `add-1` к `zero` и покажем с
помощью подстановки процесс вычисления.

```racket
(add-1 zero)
(add-1 (lambda (f) (lambda (x) x)))
(lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x))))
(lambda (f) (lambda (x) (f ((lambda (x) x) x))))
(lambda (f) (lambda (x) (f x)))
```

Таким образом, `one` имеет вид:

```racket
(define one
  (lambda (f) (lambda (x) (f x))))
```

Теперь определим `two` (двойку) как применение процедуры `add-1` к `one` и
покажем с помощью подстановки процесс вычисления.

```racket
(add-1 one)
(add-1 (lambda (f) (lambda (x) (f x))))
(lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x))))
(lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
(lambda (f) (lambda (x) (f (f x))))
```

Таким образом, `two` имеет вид:

```racket
(define two
  (lambda (f) (lambda (x) (f (f x)))))
```

Из этого можно сделать вывод, что представление любого натурального числа _n_ -
это есть ни что иное, как _n_-кратное применение функции _f_ к самой себе с
аргументом одной переменной.

Для `one` применение функции _f_ было единожды. Во втором случае (для `two`)
функция _f_ была применена дважды.

Теперь, чтобы определить процедуру сложения `+` (ограничимся двумя аргументами),
достаточно заметить тот факт, что "числа", которые мы будем складывать, это есть
процедуры.

На основе введённого раньше определения, процедура сложения - это процедура,
которая принимает в качестве аргумента функцию от одной переменной и применяет
эту функцию повторно к самой же себе _m_+_n_ раз.

"Число" _m_ вычисляется как `((m f) y)`, а "число" _n_ вычисляется как `((n f) x)`.
Если же _n_ выразить через _y_, то получим `((m f) ((n f) x))`. Отсюда видно,
что это и есть тот самый результат сложения.

В общем виде процедура сложения имеет вид:

```racket
(define (+ m n)
  (lambda (f) (lambda (x) (f ((m f) ((n f) x))))))
```
