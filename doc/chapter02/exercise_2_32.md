# [Глава 2. Построение абстракций с помощью данных](index.md#Глава-2-Построение-абстракций-с-помощью-данных)
## [2.2 Иерархические данные и свойство замыкания](index.md#22-Иерархические-данные-и-свойство-замыкания)

### Упражнение 2.32
Множество можно представить как список его различных элементов, а множество его
подмножеств как список списков. Например, если множество равно `(1 2 3)`, то
множество его подмножеств равно `(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))`.
Закончите следующее определение процедуры, которая порождает множество
подмножеств и дайте ясное объяснение, почему она работает:

```scheme
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map 〈??〉 rest)))))
```

#### Решение
Вместо 〈??〉 необходимо подставить:

```racket
(lambda (ss) (cons (car s) ss))
```

Объясняется это тем, что при определении всех подмножеств множества необходимо
определить все подмножества, куда входит каждый элемент множества. Множество
`(1 2 3)` идентично множеству `(2 3 1)`, т.е. порядок элементов не важен. Именно
поэтому не требуется находить все перестановки элементов, а только лишь те, в
которых элементы уникальны. Для этого процедура проходит по множеству, исключая
один элемент, и порождает все подмножества, в которых присутствует этот элемент.
Этот результат присоединяется к результату от прохода процедурой по множеству с
исключённым элементом, где в свою очередь производится порождение подмножеств
для каждого исключённого элемента. И так до пустого множества.

[Код](../../src/chapter02/exercise_2_32.rkt) | [Тест](../../test/chapter02/test_exercise_2_32.rkt)
--- | ---
