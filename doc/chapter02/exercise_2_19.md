# [Глава 2. Построение абстракций с помощью данных](index.md#Глава-2-Построение-абстракций-с-помощью-данных)
## [2.2 Иерархические данные и свойство замыкания](index.md#22-Иерархические-данные-и-свойство-замыкания)

### Упражнение 2.19
Рассмотрим программу подсчета способов размена из раздела 1.2.2. Было бы приятно
иметь возможность легко изменять валюту, которую эта программа использует, так,
чтобы можно было, например, вычислить, сколькими способами можно разменять
британский фунт. Эта программа написана так, что знание о валюте распределено
между процедурами `first-denomination` и `count-change` (которая знает, что
существует пять видов американских монет). Приятнее было бы иметь возможность
просто задавать список монет, которые можно использовать при размене.

Мы хотим переписать процедуру `cc` так, чтобы ее вторым аргументом был список
монет, а не целое число, которое указывает, какие монеты использовать. Тогда у
нас могли бы быть списки, определяющие типы валют:

```racket
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
```

Можно было бы вызывать `cc` следующим образом:

```racket
(cc 100 us-coins)
292
```

Это потребует некоторых изменений в программе `cc`. Ее форма останется прежней,
но со вторым аргументом она будет работать иначе, вот так:

```racket
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
          (+ (cc amount
                 (except-first-denomination coin-values))
             (cc (- amount
                    (first-denomination coin-values))
                 coin-values)))))
```

Определите процедуры `first-denomination`, `except-first-denomination` и
`no-more?` в терминах элементарных операций над списковыми структурами. Влияет
ли порядок списка `coin-values` на результат, получаемый `cc`? Почему?

#### Решение
Определения процедур не составляют особого труда. Первая должна извлекать первый
элемент списка. Вторая процедура должна возвращать так называемый "хвост" списка.
А третья - проверяет на пустоту список.

Экспериментальным путём можно убедиться в том, что расположение номиналов монет в
списке никак не влияет на результат работы процедуры размена суммы денег, которая
возвращает количество вариантов размена. Это объясняется тем, что результат
выполнения процедуры складывается из количества способов разменять сумму денег
при помощи всех типов монет, кроме первого (одного из всего доступного множества
номиналов), и количества способов разменять исходную сумму, за исключением
достоинства монеты первого типа, с использованием всех типов монет в списке.

В "левой" ветви вычислений мы всегда будет разменивать сумму денег при помощи
всех типов монет, кроме выбранной. На следующем вызове в "левой" ветви вычислений
для "левой" ветви сумма не изменится, а вот номиналов монет будет на одну меньше.
А в "правой" ветви сумма уменьшится на значение номинала, но количество номиналов
не изменится.

В "правой" ветви вычислений мы всегда будет уменьшать сумму на значение номинала
монеты, оставляя эту монету в списке. На следующем вызове "левой" ветви сумма
будет за вычетом текущего номинала, но теперь нам этот номинал не потребуется, и
мы вычтем этот номинал из списка. При вычислении "правой" ветви сумма вновь
уменьшится на значение текущего номинала, а список останется неизменным.

Это, в свою очередь, говорит о том, что не имеет значения, какой номинал монет
нужно взять первым. Так как если мы берём, допустим, первым номинал 25, то нам
следует вычислить количество вариантов размена исходной суммы при помощи всех
типов, кроме этого типа, и количество способов размена исходной суммы минус 25,
то есть минус номинал монеты, при помощи использования всех типов монет.

[Код](../../src/chapter02/exercise_2_19.rkt) | [Тест](../../test/chapter02/test_exercise_2_19.rkt)
--- | ---
