# [Глава 2. Построение абстракций с помощью данных](index.md#Глава-2-Построение-абстракций-с-помощью-данных)
## [2.2 Иерархические данные и свойство замыкания](index.md#22-Иерархические-данные-и-свойство-замыкания)

### Упражнение 2.38
Процедура `accumulate` известна также как `fold-right` (правая свертка),
поскольку она комбинирует первый элемент последовательности с результатом
комбинирования всех элементов справа от него. Существует также процедура
`fold-left` (левая свертка), которая подобна `fold-right`, но комбинирует
элементы в противоположном направлении:

```scheme
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
 ```

Каковы значения следующих выражений?

```scheme
(fold-right / 1 (list 1 2 3))

(fold-left / 1 (list 1 2 3))

(fold-right list nil (list 1 2 3))

(fold-left list nil (list 1 2 3))
```

#### Решение
Вычислим значения выражений.

```racket
(fold-right / 1 (list 1 2 3))
```
Процедура будет последовательно делить первый элемент последовательности на
следующий, заканчивая деление на инициализируемое значение аккумулятора, т.е.
результатом выполнения процедуры будет результат вычислений `1 / 2 / 3 / 1`.

```racket
(fold-left / 1 (list 1 2 3))
```

А эта процедура будет последовательно делить результат на следующий элемент
последовательности (на первом этапе вычислений реультатом будет инициализируемое
значение аккумулятора), т.е. результатом выполнения процедуры будет результат
вычислений `1 / 1 / 2 / 3`.

```racket
(fold-right list null (list 1 2 3))
```
\* вместо `nil` в диалекте лиспа Racket можно использовать `null`

В этом случае правая свёртка будет строить бинарное дерево, у которого левая
ветвь всегда содержит элемент последовательности (причём начинаться построение
будет с первого элемента последовательности), а правая ветвь всегда будет
содержать бинарное поддерево, т.е. результатом выполнения процедуры будет
дерево: `(1 (2 (3 ())))`.

```racket
(fold-left list null (list 1 2 3))
```

Левая свёртка также будет строить бинарное дерево, но левая ветвь всегда будет
содержать бинарное поддерево, а правая ветвь всегда будет содержать элемент
последовательности (причём начинаться построение будет с инициализируемого
значения аккумулятора, далее, помещая в правую ветвь первый элемент получаемой
последовательности), т.е. результатом выполнения процедуры будет дерево:
`(((() 1) 2) 3)`.

Анализируя полученные результаты, можно сказать, что процедуры левой и
правой свёртки начинают обработку последовательности по-разному. Процедура
правой свёртки применяет передаваемую операцию к первому элементу
последовательности и к результату правой свёртки на последовательности без
первого элемента, заканчивая инициализируемым значением. Процедура левой свёртки
же, наоборот, применяет передаваемую операцию к результату и к первому элементу
передаваемой последовательности. Первоначально она применяет передаваемую
операцию к инициализируемому значению и к первому элементу последовательности.

Для того, чтобы результаты обеих свёрток на одной и той же последовательности с
применением одной и той же операции к элементам последовательности были
одинаковыми, необходимо, чтобы передаваемая операция обладала свойствами
_коммутативности_ и _ассоциативности_.

А так как операция деления и построения списка не обладают такими свойствами, то
и результаты левой и правой свёрток различны. Примерами операций, обладающих
свойствами коммутативности и ассоциативности, являются сложение, умножение,
конъюнкция, объединение множеств.

Дополнительный тест (#6) показывает, что только одной коммутативности не
достаточно, сравнивая результаты левой и правой свёрток на операции модуля
разности.

[Код](../../src/chapter02/exercise_2_38.rkt) | [Тест](../../test/chapter02/test_exercise_2_38.rkt)
--- | ---
