# [Глава 2. Построение абстракций с помощью данных](index.md#Глава-2-Построение-абстракций-с-помощью-данных)
## [2.2 Иерархические данные и свойство замыкания](index.md#22-Иерархические-данные-и-свойство-замыкания)

### Упражнение 2.22
Хьюго Дум пытается переписать первую из процедур `square-list` из
[упражнения 2.21](exercise_2_21.md#Упражнение-221) так, чтобы она работала как
итеративный процесс:

```scheme
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
```

К сожалению, такое определение `square-list` выдает список результатов в порядке,
обратном желаемому. Почему?

Затем Хьюго пытается исправить ошибку, обменяв аргументы `cons`:

```scheme
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))
```

И так программа тоже не работает. Объясните это.

#### Решение
Выполним процедуру из первого варианта и, передав ей список `(list 1 2 3 4 5)`,
получим такой результат:

```racket
'(25 16 9 4 1)
```
Да, действительно, процедура работает не так, как этого мы ожидали &mdash;
результат оказался перевёрнутым.

Теперь посмотрим на код, который написал Хьюго. На каждой итерации выполнения
процедуры производится проверка переданного списка на пустоту. В случае пустого
списка процедура возвращает результат, который формируется конструированием
списка из возведения первого элемента в квадрат и списка-результата. Так как
процедура на первой итерации получает исходный список в качестве "подопытного" и
пустой список в качестве результата, то на второй итерации процедура получает
исходный список, но уже без первого элемента, который в свою очередь будет
возведён в квадрат и добавлен в пустой список-результат.

Иначе говоря, процедура берёт первый элемент списка, возводит его в квадрат и
добавляет в "голову" списка. Таким образом мы и получаем инвертированный список
результатов относительно исходного.

Далее разберёмся со вторым вариантом процедуры, которая, по мнению Хьюго, должна
исправить работу процедуры из первого варианта. Хьюго поменял только аргументы в
конструкторе. Эта идея так же не произвела должного эффекта:

```racket
'(((((() . 1) . 4) . 9) . 16) . 25)
```

В этом случаем всё очевидно. Конструктор в качестве первого аргумента берёт
весь список-результат, а в качестве второго &mdash; квадрат первого элемента
исходного списка. Таким образом, в результате будет получен список, первым
элементом которого будет другой список, в котором первый элемент будет списком,
в котором... и так до последнего элемента в исходном списке; а второй элемент,
каждого из вложенных списков, будет являться квадратом элемента списка в
соответствии с порядком обработки элементов исходного списка.
