# [Глава 2. Построение абстракций с помощью данных](index.md#Глава-2-Построение-абстракций-с-помощью-данных)
## [2.2 Иерархические данные и свойство замыкания](index.md#22-Иерархические-данные-и-свойство-замыкания)

### Упражнение 2.43
У Хьюго Дума ужасные трудности при решении [упражнения 2.42](exercise_2_42.md#Упражнение-242).
Его процедура `queens` вроде бы работает, но невероятно медленно. (Хьюго ни разу
не удается дождаться, пока она решит хотя бы задачу 6 × 6.) Когда Хьюго просит о
помощи Еву Лу Атор, она указывает, что он поменял местами порядок вложенных
отображений в вызове процедуры `flatmap`, записав его в виде

```racket
(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
```

Объясните, почему из-за такой перестановки программа работает медленно. Оцените,
насколько долго программа Хьюго будет решать задачу с восемью ферзями, если
предположить, что программа, приведенная в [упражнении 2.42](exercise_2_42.md#Упражнение-242),
решает ее за время _T_.

#### Решение
Процедура `flatmap` в "оригинальной" версии принимает количество всех расстановок
_k_ - 1 ферзей на первых _k_ - 1 вертикалях для доски размера `board-size` и для
каждой расстановки вычисляет всевозможные расстановки для следующего ферзя на
`board-size` горизонталях. А процедура `map` принимает номера всех горизонталей.

Таким образом, количество операций по вычислению расстановок для _k_-го ферзя
будет равно `board-size` * `(length (queen-cols (- k 1))` + кол-во операций для
(_k_ - 1)-го ферзя.

    Opₖ = n * qc(k - 1) + Opₖ₋₁

_qc_ - `queen-cols`,
_n_ - `board-size`

То есть рекурсивный вызов `queen-cols` будет исполнен только `board-size` раз,
так как "оригинальная" программа реализует линейно-рекурсивный процесс.

Для программы Хьюго дела обстоят печально. Процедура `flatmap`, которая теперь
принимает номера всех горизонталей, будет для *каждой* горизонтали вызывать
рекурсивно процедуру `queen-cols` для вычисления всех расстановок, которая в свою
очередь будет вызывать рекурсивно `queen-cols` _k_ - 1 раз, каждый вызов которой
будет вызывать `queen-cols` _k_ - 2 раз и т.д. А `map` как раз будет принимать
эти полученные расстановки, каждый раз вычисленные заново.

Таким образом, количество операций по вычислению расстановок для _k_-го ферзя
будет равно `board-size` * `(length (queen-cols (- k 1)))`+ кол-во операций для
(_k_ - 1)-го ферзя, умноженное на `board-size`.

    Opₖ = n * qc(k - 1) + n * Opₖ₋₁

_qc_ - `queen-cols`,
_n_ - `board-size`

То есть рекурсивный вызов `queen-cols` будет исполнен _nⁿ_ раз, так как программа
Хьюго реализует древовидно-рекурсивный процесс.

Если "оригинальная" программа решает задачу для 8 ферзей за время _T_, то
программа Хьюго будет это делать на _T⁷_ дольше. Такое различие будет в том случае,
если время фильтрации будет приблизительно одинаковым для обеих программ. Но на
самом деле это не так. В прогамме Хьюго фильтрация будет проходить по другому
виду списка расположений, нежели "оригинальная" программа. Вследствие чего
количество проходов для определения небезопасного положения будет разным. На
больших _n_ эта разница будет не столь велика. Так как количество проходов всегда меньше _n_, а количество расположений всегда больше _n_.