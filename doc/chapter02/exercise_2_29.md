# [Глава 2. Построение абстракций с помощью данных](index.md#Глава-2-Построение-абстракций-с-помощью-данных)
## [2.2 Иерархические данные и свойство замыкания](index.md#22-Иерархические-данные-и-свойство-замыкания)

### Упражнение 2.29
Бинарный мобиль состоит из двух ветвей, левой и правой. Каждая ветвь
представляет собой стержень определенной длины, с которого свисает либо гирька,
либо еще один бинарный мобиль. Мы можем представить бинарный мобиль в виде
составных данных, соединив две ветви (например, с помощью `list`):

```scheme
(define (make-mobile left right)
  (list left right))
```

Ветвь составляется из длины `length` (которая должна быть числом) и структуры
`structure`, которая может быть либо числом (представляющим простую гирьку),
либо еще одним мобилем:

```scheme
(define (make-branch length structure)
  (list length structure))
```

а. Напишите соответствующие селекторы `left-branch` и `right-branch`, которые
возвращают левую и правую ветви мобиля, а также `branch-length` и
`branch-structure`, которые возвращают компоненты ветви.

б. С помощью этих селекторов напишите процедуру `total-weight`, которая
возвращает общий вес мобиля.

в. Говорят, что мобиль _сбалансирован_, если момент вращения, действующий на его
левую ветвь, равен моменту вращения, действующему на правую ветвь (то есть длина
левого стержня, умноженная на вес груза, свисающего с него, равна
соответствующему произведению для правой стороны), и если все подмобили,
свисающие с его ветвей, также сбалансированы. Напишите предикат, который
проверяет мобили на сбалансированность.

г. Допустим, мы изменили представление мобилей, так что конструкторы теперь
приняли такой вид:

```scheme
(define (make-mobile left right)
  (cons left right))

(define (make-branch length structure)
  (cons length structure))
```

Как много Вам нужно изменить в программах, чтобы перейти на новое представление?

#### Решение
Ответы на пункты `а`, `б` и `в` даны непосредственно в
[коде](../../src/chapter02/exercise_2_29.rkt).

г. Если изменить представление мобилей, то потребуется изменить только процедуры
`left-branch`, `right-branch`, `branch-length` и `branch-structure`. В данном
случае изменяется представление со списков на пары, тогда нужно будет поменять
только две процедуры:

```racket
(define (right-branch mobile)
  (cdr mobile))

(define (branch-structure branch)
  (cdr branch))
```

Такое малое количество изменений, которое никак не затрагивает остальную логику,
обусловлено тем, что при построении архитектуры были определены барьеры
абстракции. При работе с мобилями, нам совершенно не важно, как они реализованы.
Поэтому можно разделить реализацию и логику. В дальнейшем это даёт несомненные
плюсы в использовании, среди которых безболезненное внесение изменений.

[Код](../../src/chapter02/exercise_2_29.rkt) | [Тест](../../test/chapter02/test_exercise_2_29.rkt)
--- | ---
