# [Глава 2. Построение абстракций с помощью данных](index.md#Глава-2-Построение-абстракций-с-помощью-данных)
## [2.2 Иерархические данные и свойство замыкания](index.md#22-Иерархические-данные-и-свойство-замыкания)

### Упражнение 2.37
Предположим, что мы представляем векторы _v_ = _(vᵢ)_ как последовательности
чисел, а матрицы _m_ = _(mᵢ)_ как последовательности векторов (рядов матрицы).
Например, матрица

    ┌         ┐
    │ 1 2 3 4 │
    │ 4 4 5 6 │
    │ 6 7 8 9 │
    └         ┘

представляется в виде последовательности `((1 2 3 4) (4 5 6 6) (6 7 8 9))`. Имея
такое представление, мы можем использовать операции над последовательностями,
чтобы кратко выразить основные действия над матрицами и векторами. Эти операции
(описанные в любой книге по матричной алгебре) следующие:

**Скалярное произведение** `(dot-product v w)` возвращает сумму ∑ᵢvᵢwᵢ;

**Произведение матрицы и вектора** `(matrix-*-vector m v)` возвращает вектор _t_,
где _tᵢ_ = ∑ⱼmᵢⱼvᵢ;

**Произведение матриц** `(matrix-*-matrix m n)` возвращает матрицу _p_, где
_pᵢⱼ_ = ∑ₖmᵢₖnₖⱼ

**Транспозиция** `(transpose m)` возвращает матрицу _n_, где nᵢⱼ = mⱼᵢ

Скалярное произведение мы можем определить так:

```scheme
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
```

Заполните пропуски в следующих процедурах для вычисления остальных матричных
операций. (Процедура `accumulate-n` описана в [упражнении 2.36](exercise_2_36.md#Упражнение-236).)

```scheme
(define (matrix-*-vector m v)
  (map 〈??〉 m))

(define (transpose mat)
  (accumulate-n 〈??〉 〈??〉 mat))

(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map 〈??〉 m)))
```

#### Решение
[Код](../../src/chapter02/exercise_2_37.rkt) | [Тест](../../test/chapter02/test_exercise_2_37.rkt)
--- | ---
